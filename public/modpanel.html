<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>Panel de Moderadores</title>
  <style>
    :root{
      /* Ajusta estos valores a la resoluci√≥n de tu canvas en OBS */
      --STAGE-W: 1920px;
      --STAGE-H: 1080px;
    }
    body{font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; margin:16px;}
    .row{display:flex; gap:8px; margin-bottom:10px; align-items:center; flex-wrap: wrap;}
    .small{font-size:12px; color:#666}
    .card{border:1px solid #ddd; border-radius:8px; padding:8px;}
    #stageWrap{max-width:100%; overflow:auto; transform-origin: top left;}
    #stage{
      position:relative; width:var(--STAGE-W); height:var(--STAGE-H);
      border:1px dashed #999; background:#111; margin:16px 0;
      touch-action:none; user-select:none;
    }
    .thumb{
      position:absolute; cursor:move; outline:1px solid rgba(255,255,255,.25);
      will-change: transform, opacity; transform-origin:center center;
      touch-action:none; user-select:none;
      max-width:40%; max-height:40%;
    }
	.thumb.text {
  padding: 6px 10px;
  color: #fff;
  background: transparent;     /* puedes poner un fondo temporal si quieres ver el √°rea */
  white-space: pre-wrap;       /* respeta saltos de l√≠nea */
  text-shadow: 0 0 3px rgba(0,0,0,.6);
  max-width: 60%;              /* opcional (hazlo igual en overlay o qu√≠talo en ambos) */
  line-height: 1.1;
}

    .selected{ outline:2px solid #4ade80; box-shadow:0 0 0 2px rgba(74,222,128,.2); }
    input[type=range]{ width: 220px; }
	:root{
  --frameColor: #e11d48;   /* rojo marco exterior */
  --safeColor:  #22c55e;   /* verde zona segura  */
}

/* Contenedor del marco por encima de las miniaturas */
#obsFrame {
  position:absolute;
  inset:0;
  pointer-events:none;   /* no tapa el drag */
  z-index: 9999;         /* por encima de las .thumb */
}

#obsFrame.hidden { display:none; }

#obsFrame .border {
  position:absolute;
  inset:0;
  box-shadow: 0 0 0 4px var(--frameColor) inset;
  border-radius: 0;
}

#obsFrame .safe {
  position:absolute;
  left: var(--padL, 0px);
  right: var(--padR, 0px);
  top: var(--padT, 0px);
  bottom: var(--padB, 0px);
  box-shadow: 0 0 0 2px var(--safeColor) inset;
}

/* Rejilla tipo ‚Äúregla de tercios‚Äù */
#obsFrame .grid {
  position:absolute;
  inset:0;
  background-image:
    linear-gradient(to right, rgba(255,255,255,.35) 1px, transparent 1px),
    linear-gradient(to bottom, rgba(255,255,255,.35) 1px, transparent 1px);
  background-size: calc(100%/3) 100%, 100% calc(100%/3);
  opacity: .4;
}

  </style>
</head>
<body>
  <h1>Panel de Moderadores</h1>

  <!-- Resoluci√≥n del stage (debe igualar OBS Canvas) -->
  <div class="row">
    <input id="sw" type="number" value="1920" style="width:90px"> √ó
    <input id="sh" type="number" value="1080" style="width:90px">
    <button id="setRes">Aplicar resoluci√≥n panel</button>
    <span class="small">(igual a OBS ‚Üí Ajustes ‚Üí Video ‚Üí Base (Canvas))</span>
  </div>

  <div class="row">
    <input id="modKey" type="text" placeholder="Clave moderador">
    <button id="btnLogin">Guardar clave</button>
  </div>

  <div class="row">
    <input id="url" type="text" placeholder="URL (png/jpg/webm/mp4/mp3/ogg)" style="min-width:320px;">
    <select id="type">
      <option value="image">image</option>
      <option value="video">video</option>
      <option value="audio">audio</option>
	  <option value="text">text</option> <!-- üëà nuevo -->
    </select>
    <button id="btnAddUrl">Agregar URL</button>
  </div>

  <div class="row">
    <input id="file" type="file" accept="image/*,video/*,audio/*">
    <button id="btnUpload">Subir</button>
    <span class="small">(se alojar√° en /uploads)</span>
  </div>
  
  <div class="card">
  <div class="row"><strong>Nuevo texto</strong></div>
  <div class="row">
    <input id="txtContent" type="text" placeholder="Escribe el texto..." style="min-width:320px;">
    <label class="small">Tama√±o(px) <input id="txtSize" type="number" value="48" style="width:90px"></label>
    <label class="small">Color <input id="txtColor" type="color" value="#ffffff"></label>
    <button id="btnAddText">Agregar texto</button>
  </div>
</div>


  <!-- Controles del elemento seleccionado -->
  <div class="card" id="controls" style="display:none;">
    <div class="row"><strong>Elemento seleccionado:</strong> <span id="selId" class="small"></span></div>
    <div class="row">
      <label>Escala 
        <input id="scale" type="range" min="0.2" max="3" step="0.05"><span id="scaleVal" class="small"></span>
      </label>
      <label>Rotaci√≥n 
        <input id="rot" type="range" min="-180" max="180" step="1"><span id="rotVal" class="small"></span>
      </label>
      <label>Opacidad 
        <input id="opacity" type="range" min="0" max="1" step="0.05"><span id="opacityVal" class="small"></span>
      </label>
    </div>
	<div id="textControls" class="row" style="display:none;">
  <input id="editText" type="text" placeholder="Editar texto..." style="min-width:320px;">
  <label class="small">Tama√±o(px) <input id="editFontSize" type="number" value="48" style="width:90px"></label>
  <label class="small">Color <input id="editColor" type="color" value="#ffffff"></label>
</div>

    <div class="row">
      <button id="front">Al frente</button>
      <button id="back">Al fondo</button>
      <button id="toggleVis">Mostrar/Ocultar</button>
      <button id="remove">Eliminar</button>
    </div>
  </div>
<div class="card">
  <div class="row">
    <strong>Marco OBS</strong>
  </div>
  <div class="row">
    <label><input type="checkbox" id="showFrame" checked> Mostrar marco</label>
    <label><input type="checkbox" id="showGrid" checked> Rejilla (tercios)</label>
    <label><input type="checkbox" id="showSafe" checked> Zona segura</label>
  </div>
  <div class="row">
    <label>Preset:
      <select id="safePreset">
        <option value="0">Sin zona segura</option>
        <option value="5" selected>5%</option>
        <option value="10">10%</option>
        <option value="custom">Custom</option>
      </select>
    </label>
    <span class="small">Custom (px):</span>
    <label>Top <input type="number" id="padT" value="0" style="width:80px"></label>
    <label>Right <input type="number" id="padR" value="0" style="width:80px"></label>
    <label>Bottom <input type="number" id="padB" value="0" style="width:80px"></label>
    <label>Left <input type="number" id="padL" value="0" style="width:80px"></label>
    <button id="applyFrame">Aplicar</button>
  </div>
  <div class="row small">
    El marco rojo delimita el tama√±o real del overlay en OBS. La zona segura (verde) te ayuda a no pegar elementos a los bordes.
  </div>
</div>

  <div id="stageWrap"><div id="stage">
  <!-- Marco superpuesto (no interfiere con el drag) -->
  <div id="obsFrame" class="hidden">
    <div class="border"></div>
    <div class="grid"></div>
    <div class="safe"></div>
  </div>
</div>
</div>




  <script src="/socket.io/socket.io.js"></script>
  <script>
    const socket = io();

    // === Resoluci√≥n del stage (persistente) ===
    const savedW = localStorage.getItem('STAGE_W') || '1920';
    const savedH = localStorage.getItem('STAGE_H') || '1080';
    document.getElementById('sw').value = savedW;
    document.getElementById('sh').value = savedH;
    document.documentElement.style.setProperty('--STAGE-W', savedW + 'px');
    document.documentElement.style.setProperty('--STAGE-H', savedH + 'px');

    document.getElementById('setRes').onclick = () => {
      const w = document.getElementById('sw').value || '1920';
      const h = document.getElementById('sh').value || '1080';
      localStorage.setItem('STAGE_W', w);
      localStorage.setItem('STAGE_H', h);
      document.documentElement.style.setProperty('--STAGE-W', w + 'px');
      document.documentElement.style.setProperty('--STAGE-H', h + 'px');
    };

    // === Clave de moderador ===
    let MOD_KEY = localStorage.getItem('MOD_KEY') || '';
    document.getElementById('modKey').value = MOD_KEY;
    document.getElementById('btnLogin').onclick = () => {
      MOD_KEY = document.getElementById('modKey').value.trim();
      localStorage.setItem('MOD_KEY', MOD_KEY);
      alert('Clave guardada');
    };

    async function uploadFile() {
      const f = document.getElementById('file').files[0];
      if (!f) return alert('No file seleccionado');
      const fd = new FormData(); fd.append('file', f);
      const res = await fetch('/api/upload', { method:'POST', headers:{'x-mod-key':MOD_KEY}, body:fd });
      const j = await res.json();
      if (!j.ok) return alert('Error:'+j.error);
      return j.url;
    }

    // === Estado local / selecci√≥n ===
    let state=[];                 // espejo del overlay (desde server)
    let selectedId=null;          // id del item seleccionado
    let lastSend=0; const SEND_MS=1000/30; // throttle ~30fps para sliders

    function selectItem(id){
  selectedId = id;
  document.querySelectorAll('.thumb').forEach(el => el.classList.toggle('selected', el.dataset.id === id));
  const it = state.find(e=>e.id===id);
  const controls = document.getElementById('controls');
  const textControls = document.getElementById('textControls');

  if (!it) { controls.style.display='none'; return; }
  controls.style.display='block';
  document.getElementById('selId').textContent = '#' + id;

  // sliders ya existentes:
  const s = document.getElementById('scale'); s.value = it.scale ?? 1; document.getElementById('scaleVal').textContent = s.value;
  const r = document.getElementById('rot');   r.value = it.rot ?? 0;   document.getElementById('rotVal').textContent   = r.value + '¬∞';
  const o = document.getElementById('opacity'); o.value = it.opacity ?? 1; document.getElementById('opacityVal').textContent = o.value;

  // mostrar controles de texto si corresponde
  if (it.type === 'text') {
    textControls.style.display = 'flex';
    document.getElementById('editText').value = it.text || '';
    document.getElementById('editFontSize').value = it.fontSize || 48;
    document.getElementById('editColor').value = it.color || '#ffffff';
  } else {
    textControls.style.display = 'none';
  }
}


    function throttledUpdate(id, patch){
      const now = performance.now();
      if (now - lastSend > SEND_MS) {
        lastSend = now;
        socket.emit('item:update', { id, patch });
      }
    }

    // === Render del stage con arrastre + preview en vivo ===
    function renderStage(){
      const stage=document.getElementById('stage');
      stage.innerHTML='';
      state.forEach(it=>{
        const el=document.createElement(it.type==='image'?'img':'div');
        el.className='thumb'; el.dataset.id=it.id;
        if(it.type==='image') el.src=it.url; else el.textContent=it.type.toUpperCase();
        el.style.opacity = it.opacity==null?1:it.opacity;
        el.style.zIndex = (it.zIndex||1);
        el.style.transform=`translate3d(${it.x||0}px,${it.y||0}px,0) scale(${it.scale||1}) rotate(${it.rot||0}deg)`;
        if (selectedId === it.id) el.classList.add('selected');
        stage.appendChild(el);
		const el = (it.type === 'image')
  ? document.createElement('img')
  : (it.type === 'text')
    ? document.createElement('div')
    : document.createElement('div'); // video/audio muestran una etiqueta simple en el panel

el.className = 'thumb' + (it.type === 'text' ? ' text' : '');
el.dataset.id = it.id;

if (it.type === 'image') {
  el.src = it.url;
} else if (it.type === 'text') {
  el.textContent = it.text || 'Texto';
  el.style.fontSize = (it.fontSize || 48) + 'px';
  el.style.color = it.color || '#ffffff';
}


        el.onclick = (ev)=>{ ev.stopPropagation(); selectItem(it.id); };

        // Drag fluido con requestAnimationFrame + item:preview
        let dragging=false; let tx=it.x||0, ty=it.y||0; let anim;
        const move=(e)=>{ if(!dragging) return;
          const rect=stage.getBoundingClientRect();
          tx=e.clientX-rect.left; ty=e.clientY-rect.top;
        };
        const loop=()=>{ 
          // pinta local
          el.style.transform=`translate3d(${tx}px,${ty}px,0) scale(${it.scale||1}) rotate(${it.rot||0}deg)`;
          // preview en vivo hacia el overlay (no persiste)
          socket.emit('item:preview', { id: it.id, x: tx, y: ty });
          anim=requestAnimationFrame(loop);
        };
        el.onpointerdown=(e)=>{ dragging=true; el.setPointerCapture(e.pointerId); selectItem(it.id); anim=requestAnimationFrame(loop); };
        el.onpointermove=move;
        el.onpointerup=(e)=>{ 
          dragging=false; el.releasePointerCapture(e.pointerId); 
          if(anim) cancelAnimationFrame(anim);
          // commit final (s√≠ persiste)
          socket.emit('item:update',{ id:it.id, patch:{ x:tx, y:ty } });
        };
      });

      // click vac√≠o ‚Üí deseleccionar
      stage.onclick = ()=>{ 
        selectedId=null; 
        document.querySelectorAll('.thumb').forEach(t=>t.classList.remove('selected')); 
        document.getElementById('controls').style.display='none'; 
      };
	  ensureObsFrame(); // <-- asegura el marco por encima del contenido

	 
// === Marco OBS ===
function ensureObsFrame(){
  const stage = document.getElementById('stage');
  let frame = document.getElementById('obsFrame');
  if (!frame) {
    frame = document.createElement('div');
    frame.id = 'obsFrame';
    frame.innerHTML = '<div class="border"></div><div class="grid"></div><div class="safe"></div>';
    stage.appendChild(frame);
  } else {
    // re-append para traerlo al frente si el render limpi√≥ el stage
    stage.appendChild(frame);
  }
  updateObsFrame(); // sincroniza estado visual
}

function updateObsFrame(){
  const stage = document.getElementById('stage');
  const frame = document.getElementById('obsFrame');
  if (!frame) return;

  const showFrame = document.getElementById('showFrame').checked;
  const showGrid  = document.getElementById('showGrid').checked;
  const showSafe  = document.getElementById('showSafe').checked;
  const preset    = document.getElementById('safePreset').value;

  // Mostrar/ocultar contenedor
  frame.classList.toggle('hidden', !showFrame);

  // Mostrar/ocultar capas
  frame.querySelector('.grid').style.display  = showGrid ? 'block' : 'none';
  frame.querySelector('.safe').style.display  = showSafe ? 'block' : 'none';

  // C√°lculo de paddings de la zona segura
  const W = stage.clientWidth;
  const H = stage.clientHeight;

  let padT = +document.getElementById('padT').value || 0;
  let padR = +document.getElementById('padR').value || 0;
  let padB = +document.getElementById('padB').value || 0;
  let padL = +document.getElementById('padL').value || 0;

  if (preset !== 'custom') {
    const p = Number(preset) || 0; // %
    padT = padB = Math.round(H * p / 100);
    padL = padR = Math.round(W * p / 100);
    // refleja en inputs para que veas los px reales
    document.getElementById('padT').value = padT;
    document.getElementById('padB').value = padB;
    document.getElementById('padL').value = padL;
    document.getElementById('padR').value = padR;
  }

  // Aplica como variables CSS al propio frame
  frame.style.setProperty('--padT', padT + 'px');
  frame.style.setProperty('--padR', padR + 'px');
  frame.style.setProperty('--padB', padB + 'px');
  frame.style.setProperty('--padL', padL + 'px');
}

// Listeners UI marco
['showFrame','showGrid','showSafe','safePreset','padT','padR','padB','padL'].forEach(id=>{
  const el = document.getElementById(id);
  if (el) el.addEventListener('input', updateObsFrame);
});
document.getElementById('applyFrame')?.addEventListener('click', updateObsFrame);

 
	  
    }

    // === Sliders (escala/rotaci√≥n/opacidad) con throttle ===
    document.getElementById('scale').oninput   = (e)=>{ if(!selectedId) return; const v=Number(e.target.value); document.getElementById('scaleVal').textContent=v; throttledUpdate(selectedId,{scale:v}); };
    document.getElementById('rot').oninput     = (e)=>{ if(!selectedId) return; const v=Number(e.target.value); document.getElementById('rotVal').textContent=v+'¬∞'; throttledUpdate(selectedId,{rot:v}); };
    document.getElementById('opacity').oninput = (e)=>{ if(!selectedId) return; const v=Number(e.target.value); document.getElementById('opacityVal').textContent=v; throttledUpdate(selectedId,{opacity:v}); };

    // === Botones de control ===
    document.getElementById('front').onclick = () => {
      const it = state.find(e=>e.id===selectedId); if(!it) return;
      const maxZ = state.length ? Math.max(...state.map(i=>i.zIndex||0)) : 1;
      socket.emit('item:update', { id: selectedId, patch: { zIndex: maxZ + 1 } });
    };
    document.getElementById('back').onclick = () => {
      const it = state.find(e=>e.id===selectedId); if(!it) return;
      socket.emit('item:update', { id: selectedId, patch: { zIndex: 1 } });
    };
    document.getElementById('toggleVis').onclick = () => {
      const it = state.find(e=>e.id===selectedId); if(!it) return;
      socket.emit('item:update', { id: selectedId, patch: { visible: !(it.visible !== false) } });
    };
    document.getElementById('remove').onclick = () => {
      if (!selectedId) return;
      socket.emit('item:remove', selectedId);
      selectedId = null;
      document.getElementById('controls').style.display='none';
    };
	function selectItem(id){
  selectedId = id;
  document.querySelectorAll('.thumb').forEach(el => el.classList.toggle('selected', el.dataset.id === id));
  const it = state.find(e=>e.id===id);
  const controls = document.getElementById('controls');
  const textControls = document.getElementById('textControls');

  if (!it) { controls.style.display='none'; return; }
  controls.style.display='block';
  document.getElementById('selId').textContent = '#' + id;

  // sliders ya existentes:
  const s = document.getElementById('scale'); s.value = it.scale ?? 1; document.getElementById('scaleVal').textContent = s.value;
  const r = document.getElementById('rot');   r.value = it.rot ?? 0;   document.getElementById('rotVal').textContent   = r.value + '¬∞';
  const o = document.getElementById('opacity'); o.value = it.opacity ?? 1; document.getElementById('opacityVal').textContent = o.value;

  // mostrar controles de texto si corresponde
  if (it.type === 'text') {
    textControls.style.display = 'flex';
    document.getElementById('editText').value = it.text || '';
    document.getElementById('editFontSize').value = it.fontSize || 48;
    document.getElementById('editColor').value = it.color || '#ffffff';
  } else {
    textControls.style.display = 'none';
  }
}


    // === Wire b√°sico para altas ===
    document.getElementById('btnAddUrl').onclick=()=>{
      const url=document.getElementById('url').value.trim();
      const type=document.getElementById('type').value;
      if(!url) return alert('URL vac√≠a');
     socket.emit('item:add',{type,url,x:240,y:180,scale:1,rot:0,opacity:1,visible:true,loop:true});

      document.getElementById('url').value='';
    };

    document.getElementById('btnUpload').onclick=async()=>{
      const url=await uploadFile(); if(!url) return;
      let type='image'; const l=url.toLowerCase();
      if(/\.(mp4|webm|ogv|mkv|mov)$/.test(l)) type='video';
      if(/\.(mp3|wav|ogg|m4a|aac)$/.test(l)) type='audio';
      socket.emit('item:add',{type,url,x:240,y:180,scale:1,rot:0,opacity:1,visible:true});
    };
document.getElementById('btnAddText').onclick = () => {
  const text = document.getElementById('txtContent').value.trim() || 'Texto';
  const fontSize = Number(document.getElementById('txtSize').value) || 48;
  const color = document.getElementById('txtColor').value || '#ffffff';

  socket.emit('item:add', {
    type: 'text',
    text,
    fontSize,
    color,
    x: 200, y: 150,
    scale: 1, rot: 0, opacity: 1, visible: true
  });

  document.getElementById('txtContent').value = '';
};


    // === Socket events m√≠nimos para re-render ===
    function syncUI(){ renderStage(); }
    socket.on('state:init',(st)=>{state=st;syncUI();});
    socket.on('item:added',(it)=>{state.push(it);syncUI();});
    socket.on('item:updated',({id,patch})=>{
      const i=state.findIndex(e=>e.id===id); if(i>-1) state[i]=patch; 
      // Si el cambio fue de este mismo cliente, igual re-render para mantener selecci√≥n
      syncUI();
      if (selectedId === id) selectItem(id);
    });
    socket.on('item:removed',(id)=>{state=state.filter(e=>e.id!==id);syncUI(); if(selectedId===id){selectedId=null;document.getElementById('controls').style.display='none';}});
    socket.on('items:cleared',()=>{state=[];syncUI(); selectedId=null;document.getElementById('controls').style.display='none';});
  </script>
</body>
</html>
